#
#
# This file is part of Appcelerator.
#
# Copyright 2006-2008 Appcelerator, Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
require 'tempfile'
require 'tmpdir'


BUILD_DIR = File.dirname(__FILE__)
require File.expand_path("#{BUILD_DIR}/../build.rb")
build_config = load_config(BUILD_DIR)
JS_PATH = "javascripts"
WEBSDK_STAGE_DIR = "#{STAGE_DIR}/websdk"


desc 'build websdk files'
task :default do
  js_dir = "#{WEBSDK_STAGE_DIR}/#{JS_PATH}" # staging location
  js_source = "#{BUILD_DIR}/src/js"

  clean_dir(WEBSDK_STAGE_DIR)

  FileUtils.mkdir_p js_dir

  puts 'Compiling appcelerator-lite.js...' if VERBOSE
  # files that need to be included before the others in the directory
  jslite_prefiles = %w(debug.js string.js uri.js core.js object.js datetime.js config.js compiler.js dom.js cookie.js servicebroker.js types.js observable.js)
  jslite = js_dir+'/appcelerator-lite.js'
  
  LICENSE_HEADER=<<END_LICENSE
/*!
 * This file is part of Appcelerator.
 *
 * Copyright 2006-2008 Appcelerator, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/
END_LICENSE

  append_file(LICENSE_HEADER,jslite,true)
  
  rel = build_config[:version].to_s.split('.')

  # fix the release information in the file
  bf = File.read(js_source+'/bootstrap.js')
  bf.gsub!('${version.major}',rel[0])
  bf.gsub!('${version.minor}',rel[1])
  bf.gsub!('${version.rev}',rel[2]||'0')
  append_file(bf,jslite,true)

  jslite_prefiles.each do |file|
    append_file(js_source+'/'+file, jslite)
  end

  # other files to avoid automatically adding
  EXCLUDED_FILES = jslite_prefiles + %w(bootstrap.js prolog.js epilog.js)
  
  def not_already_included(path)
    not EXCLUDED_FILES.find{ |excluded_file| path.include? excluded_file }
  end

  js_files = Dir["#{js_source}/*.js"].select{|path| not_already_included path}
  # don't filter out excluded files from subdirs,
  # because we have some duplicate filenames
  js_files += Dir["#{js_source}/*/*.js"]
  
  # must sort after including subdirs
  js_files.sort.each {|path| append_file(path, jslite) unless path =~ /tracker\.js/}
  append_file("#{js_source}/tracker.js", jslite)
  append_file("#{js_source}/epilog.js", jslite)

  puts 'Compiling appcelerator-debug.js...' if VERBOSE
  
  jsdebug = js_dir+'/appcelerator-debug.js'
  append_file(LICENSE_HEADER,jsdebug,true)
  append_file("\n/* The following files are subject to license agreements by their respective license owners */\n", jsdebug, true)
  append_file(js_source+'/prolog.js', jsdebug)
  thirdparty = [
    'prototype/prototype.js',
    'scriptaculous/scriptaculous.js',
    'scriptaculous/effects.js',
    'scriptaculous/dragdrop.js',
    'scriptaculous/resizable.js',
    'jel/jel_datetime.js'
  ]
  thirdparty.each do |file|
    append_file(BUILD_DIR+'/lib/'+file, jsdebug)
  end
  append_file("\n/* END THIRD PARTY SOURCE */\n", jsdebug, true)
  append_file(jslite, jsdebug)
  
  puts 'Compiling appcelerator.js...' if VERBOSE
  jsout = js_dir+'/appcelerator.js'
  jstemp = js_dir+'/appcelerator-temp.js'
  
  # Strip out scriptaculous's load - since we include its files already
  jsd = File.read(jsdebug)
  jsd.gsub!('Scriptaculous.load();','')
  jsdf = File.open(jsdebug,'w+')
  jsdf.write jsd
  jsdf.close
  

  if COMPRESS
    puts "Compressing appcelerator.js"

    js = compress_and_mangle(File.read(jsdebug))
    f = File.open(jstemp,'w')
    f.write js
    f.close

    FileUtils.rm jsout if File.exists?(jsout)
    append_file(LICENSE_HEADER, jsout, true)
    append_file(jstemp, jsout)

    js = compress_and_mangle(File.read(jslite))
    f = File.open(jslite,'w')
    f.write js
    f.close

    FileUtils.rm jstemp if File.exists?(jstemp)
    append_file(LICENSE_HEADER, jstemp, true)
    append_file(jslite, jstemp)
    FileUtils.rm jslite
    append_file(jstemp, jslite)
    FileUtils.rm jstemp

  else
    FileUtils.cp jsdebug, jsout
  end

  puts "Archiving JS/Web files..." if VERBOSE
  zipfile = "#{STAGE_DIR}/websdk_#{build_config[:version]}.zip"
  FileUtils.rm_rf zipfile if File.exists? zipfile
  Zip::ZipFile.open(zipfile, Zip::ZipFile::CREATE) do |zipfile|
    zipfile.add("#{JS_PATH}/appcelerator-lite.js",jslite)
    zipfile.add("#{JS_PATH}/appcelerator-debug.js",jsdebug)
    zipfile.add("#{JS_PATH}/appcelerator.js",jsout)
    zipfile.get_output_stream('build.yml') {|f| f.puts build_config.to_yaml }
    %w(control layout theme behavior).each do |type|
      Dir["#{STAGE_DIR}/#{type}*.zip"].each do |includefile|
        zipfile.add "_install/#{File.basename(includefile)}", includefile
      end
    end
    Find.find("#{BUILD_DIR}/src/web") do |path|
      pathname = Pathname.new(path)
      path_root = Pathname.new("#{BUILD_DIR}/src/web")
      if not path.include? '.svn' and not path.include? '.DS_Store' and pathname.file?
        filename = pathname.relative_path_from(path_root).to_s
        zipfile.add(filename,path) if not filename =~ /^js(.*)\.js$/
      end
    end
    Find.find("#{BUILD_DIR}/src/common") do |path|
      pathname = Pathname.new(path)
      path_root = Pathname.new("#{BUILD_DIR}/src/common")
      if not path.include? '.svn' and not path.include? '.DS_Store' and pathname.file?
        filename = pathname.relative_path_from(path_root).to_s
        zipfile.add('common/' + filename,path)
      end
    end
  end
end

task :test => [:default] do
  copy_tests("#{BUILD_DIR}/test/webunit", "#{STAGE_DIR}/webunit")
  copy_tests("#{BUILD_DIR}/test/performance", "#{STAGE_DIR}/performance")
end

def copy_tests(test_src_path, test_dst_path)
  widgets_src_path = "#{BUILD_DIR}/../widgets"
  widgets_dst_path = "#{test_dst_path}/widgets"
  
  #FileUtils.rm_r(test_dst_path, :verbose => VERBOSE) if File.exists? test_dst_path
  cp_r(test_src_path, test_dst_path)
  FileUtils.cp_r("#{WEBSDK_STAGE_DIR}/#{JS_PATH}", test_dst_path) # there's no svn garbage here
  FileUtils.mkdir_p(widgets_dst_path, :verbose => VERBOSE)
  cp_r("#{BUILD_DIR}/src/common",       "#{test_dst_path}/widgets/common")
  cp_r("#{BUILD_DIR}/src/web/images/", "#{test_dst_path}/images/")
  cp_r("#{BUILD_DIR}/src/web/swf/", "#{test_dst_path}/swf/")

  # copy all widgets (without building, because that is a pain)
  Dir["#{widgets_src_path}/*/src/"].each do |file|
    name = file[/widgets\/([^\/]+)\/src/,1]
    tf = "#{widgets_dst_path}/#{name}"
    sf = "#{file}#{name}.js"
    utf = File.join(tf,"#{name}_debug.js")
    if File.exists? utf
      a = md5 utf
      b = md5 sf
      next if a==b
    end
    cp_r(file,"#{widgets_dst_path}/#{name}")
    js = File.read sf
    puts "+ compressing #{sf}" if VERBOSE
    jsout = compress_and_mangle(js,:js)
    f = File.open(File.join(tf,"#{name}.js"),'w')
    f.write jsout
    f.close
    f = File.open(utf,'w')
    f.write js
    f.close
  end  
  
  %w(controls layouts behaviors).each do |name|
    FileUtils.mkdir_p "#{test_dst_path}/components/#{name}"
    Dir["#{BUILD_DIR}/../#{name}/*"].each do |file|
      next unless File.directory? file
      aname = File.basename(file)
      sf = "#{file}/#{aname}.js"
      td = "#{test_dst_path}/components/#{name}/#{aname}/"
      utf = File.join(td,"#{aname}_debug.js")
      if File.exists? utf
        a = md5 utf
        b = md5 sf
        next if a==b
      end
      cp_r("#{BUILD_DIR}/../#{name}/#{aname}/",td)
      js = File.read sf
      t = File.join(td,"#{aname}.js")
      puts "+ compressing #{t}" if VERBOSE
      jsout = compress_and_mangle(js,:js)
      f = File.open(t,'w')
      f.write jsout
      f.close
      f = File.open(utf,'w')
      f.write js
      f.close
    end
  end

  Dir["#{BUILD_DIR}/../themes/*"].each do |file|
    next unless File.directory?(file)
    type = File.basename(file)
    Dir["#{BUILD_DIR}/../themes/#{type}/*"].each do |f|
      control = File.basename(f)
      Dir["#{BUILD_DIR}/../themes/#{type}/#{control}/*"].each do |fn|
        next unless File.directory?(fn)
        theme = File.basename(fn)
        tf = "#{test_dst_path}/components/#{type}/#{control}/themes/#{theme}/#{theme}.js"
        utf = "#{test_dst_path}/components/#{type}/#{control}/themes/#{theme}/#{theme}_debug.js"
        if File.exists? utf
          md5a = md5(utf)
          md5b = md5("#{BUILD_DIR}/../themes/#{type}/#{control}/#{theme}/#{theme}.js")
          next if md5a == md5b
        end
        cp_r("#{BUILD_DIR}/../themes/#{type}/#{control}/#{theme}/","#{test_dst_path}/components/#{type}/#{control}/themes/#{theme}")
        puts "+ compressing #{tf}" if VERBOSE
        jsf = "#{test_dst_path}/components/#{type}/#{control}/themes/#{theme}/#{theme}.js"
        js = File.read tf
        jsout = compress_and_mangle(js,:js)
        f = File.open(tf,'w')
        f.write jsout
        f.close
        f = File.open(utf,'w')
        f.write js
        f.close
      end
    end
  end
  FileUtils.cp_r("#{BUILD_DIR}/lib/jquery/jquery.js","#{test_dst_path}/javascripts")
  FileUtils.cp_r("#{BUILD_DIR}/src/web/component_notfound.html","#{test_dst_path}")
end

namespace :selenium do 
  task :start do
      start_selenium()
  end
  
  task :stop do 
      stop_selenium()
  end
  
  task :all => [:test] do 
      run_test([{:browser_name=>"Firefox Tests", :browser=>"firefox"},
                {:browser_name=>'IE Tests', :browser=>'iexplore'}])
  end
  
  task :firefox => [:test] do 
      run_test([{:browser_name=>"Firefox Tests", :browser=>"firefox"}])
  end

  task :safari => [:test] do 
      run_test([{:browser_name=>"Safari Tests", :browser=>'safari'}])
  end
  
  task :ie => [:test] do 
      run_test([{:browser_name=>'IE Tests', :browser=>"iexplore"}])
  end
end

namespace :webrick do 
  task :start do
    start_webrick()
  end
  
  task :stop do 
    stop_webrick()
  end
end

# copies everything except hidden directories
def cp_r(src,dst)
  src_root = Pathname.new(src)
  FileUtils.mkdir_p(dst, :verbose => VERBOSE) unless File.exists? dst
  Dir["#{src}/**/**"].each do |abs_path|
    src_path = Pathname.new(abs_path)
    rel_path = src_path.relative_path_from(src_root)
    dst_path = "#{dst}/#{rel_path.to_s}"
    
    next if abs_path.include? '.svn'
    
    if src_path.directory?
      FileUtils.mkdir_p(dst_path, :verbose => VERBOSE)
    elsif src_path.file?
      FileUtils.cp(abs_path, dst_path, :verbose => VERBOSE)
    end
  end
end

def start_webrick()
  if(File.exists?("#{STAGE_DIR}/tmp/webrick.pid"))
    return false
  end
  p "Starting Webrick"
  
  FileUtils.mkdir_p("#{STAGE_DIR}/tmp/", :verbose => true)
  
  if RUBY_PLATFORM.match(/win32/)
    require 'win32/process'
    process_info = Process.create(:app_name => "ruby  #{BUILD_DIR}\\test\\lib\\start_webrick.rb #{STAGE_DIR}")
    File.open("#{STAGE_DIR}/tmp/webrick.pid", "w") { |file| 
      file.puts(process_info.process_id)
    }
  else 
    pid = fork
    if pid 
      File.open("#{STAGE_DIR}/tmp/webrick.pid", "w") { |file| 
        file.puts(pid)
      }
    else 
      exec "ruby  #{BUILD_DIR}/test/lib/start_webrick.rb #{STAGE_DIR}"
    end
  end
  
  return true
end 

def kill_process(file_name)
  signum = 15
  if RUBY_PLATFORM.match(/win32/)
    require 'win32/process'
    signum = 5
  end
  file = File.open(file_name)
  pid = file.gets.strip!.to_i
  file.close
  p "Attempting to kill: #{pid}"
  Process.kill(signum, pid)
  File.delete(file_name)
end

def end_tests(success)
    stop_selenium() if selenium
    stop_webrick() if webrick
    
    if(!success)
        exit -1
    end
end

def stop_webrick()
  kill_process("#{STAGE_DIR}/tmp/webrick.pid")
end

def start_selenium()
  if(File.exists?("#{STAGE_DIR}/tmp/selenium.pid"))
    return false
  end
  
  p "Starting Selenium"
  FileUtils.mkdir_p("#{STAGE_DIR}/tmp/", :verbose => true)
  
  if RUBY_PLATFORM.match(/win32/)
    require 'win32/process'
    log = File.open("#{STAGE_DIR}/tmp/selenium.log", "w")
    process_info = Process.create(
        :app_name => "java -jar #{BUILD_DIR}\\test\\lib\\selenium-server.jar -browserSessionReuse",
        :startup_info => {:stdout => log},
        :creation_flags => Windows::Process::CREATE_NEW_PROCESS_GROUP
    )
    File.open("#{STAGE_DIR}/tmp/selenium.pid", "w") { |file| 
      file.puts(process_info.process_id)
    }
  else 
    pid = fork
    if pid 
      File.open("#{STAGE_DIR}/tmp/selenium.pid", "w") { |file| 
        file.puts(pid)
      }
    else
      $stdout.close
      $stdout = open("#{STAGE_DIR}/tmp/selenium.log", "w") 
      exec "java -jar #{BUILD_DIR}/test/lib/selenium-server.jar -browserSessionReuse"
      p "Shouldn't get here"
    end
  end
  
  return true
end

def stop_selenium()
  kill_process("#{STAGE_DIR}/tmp/selenium.pid")
end

def run_test(browsers)
    selenium = start_selenium()
    webrick = start_webrick()
    
    sleep 5 if( selenium or webrick)
    
    success = true
    browsers.each { |browser| 
        success = success && run_selenium_tests(browser[:browser_name], browser[:browser])
        system('taskkill /IM firefox.exe')  if RUBY_PLATFORM.match(/win32/) && browser[:browser] == "firefox"
    }
    
    # make selenium clean up on windows.  Bad assumption
    # that nobody is developing the sdk and running the
    # selenium tests with firefox running
    
    stop_selenium() if selenium
    stop_webrick() if webrick
    
    if(!success)
        throw "Selenium Tests Failed"
    end
end

def run_selenium_tests(browser_name, browser)
  require 'test/unit/testsuite'
  require 'test/unit/ui/console/testrunner'
  require 'test/lib/selenium'
  require 'test/lib/selenium_unit.rb'

  #
  # You need to manually include the tests
  # to be run here.  
  #
  require 'test/selenium/app_button_test'
  require 'test/selenium/app_calendar_test'
  require 'test/selenium/app_content_test'
  require 'test/selenium/app_datacache_test'
  require 'test/selenium/app_panel_test'
  require 'test/selenium/messaging_test'
  #
  # End includes for unit test files
  #
  
  results = Test::Unit::UI::Console::TestRunner.run(build_suite(browser_name, browser, 
         "http://localhost:9002"))
         
  if(results.error_count > 0 or results.failure_count > 0)
      return false
  end
  
  return true
end

def build_suite(name, browser, location)
    tests = ENV['tests']
    if tests 
        tests = tests.split(',')
    end
    
    suite = Test::Unit::SeleniumTestSuite.new(name, browser, location, "#{STAGE_DIR}/reports/#{browser}")
    ObjectSpace::each_object(Class) { |klass| 
        if klass < Test::Unit::SeleniumTestCase and (tests.nil? or tests.include?(klass.to_s))
            puts "Adding: #{klass}"
            suite << klass.suite 
        end
    }
    return suite
end
