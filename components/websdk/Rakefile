#
# This file is part of Appcelerator.
#
# Copyright (C) 2006-2008 by Appcelerator, Inc. All Rights Reserved.
# For more information, please visit http://www.appcelerator.org
#
# Appcelerator is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


BUILD_DIR = File.dirname(__FILE__)
require File.expand_path("#{BUILD_DIR}/../build.rb")
build_config = load_config(BUILD_DIR)
JS_PATH = "javascripts"
WEBSDK_STAGE_DIR = "#{STAGE_DIR}/websdk"

desc 'build websdk files'
task :default do
  js_dir = "#{WEBSDK_STAGE_DIR}/#{JS_PATH}" # staging location
  js_source = "#{BUILD_DIR}/src/js"

  clean_dir(WEBSDK_STAGE_DIR)

  FileUtils.mkdir_p js_dir

  puts 'Compiling appcelerator-lite.js...' if VERBOSE
  # files that need to be included before the others in the directory
  jslite_prefiles = %w(core.js debug.js string.js object.js datetime.js config.js compiler.js dom.js cookie.js servicebroker.js types.js)
  jslite = js_dir+'/appcelerator-lite.js'
  
  LICENSE_HEADER=<<END_LICENSE
/*
 * This file is part of Appcelerator.
 *
 * Copyright (C) 2006-2008 by Appcelerator, Inc. All Rights Reserved.
 * For more information, please visit http://www.appcelerator.org
 *
 * Appcelerator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
END_LICENSE

  append_file(LICENSE_HEADER,jslite,true)
  
  rel = build_config[:version].to_s.split('.')

  # fix the release information in the file
  bf = File.read(js_source+'/bootstrap.js')
  bf.gsub!('${version.major}',rel[0])
  bf.gsub!('${version.minor}',rel[1])
  bf.gsub!('${version.rev}',rel[2]||'0')
  append_file(bf,jslite,true)

  jslite_prefiles.each do |file|
    append_file(js_source+'/'+file, jslite)
  end

  # other files to avoid automatically adding
  EXCLUDED_FILES = jslite_prefiles + %w(bootstrap.js prolog.js epilog.js)
  
  def not_already_included(path)
    not EXCLUDED_FILES.find{ |excluded_file| path.include? excluded_file }
  end

  js_files = Dir["#{js_source}/*.js"].select{|path| not_already_included path}
  # don't filter out excluded files from subdirs,
  # because we have some duplicate filenames
  js_files += Dir["#{js_source}/*/*.js"]
  
  # must sort after including subdirs
  js_files.sort.each {|path| append_file(path, jslite) }
  append_file("#{js_source}/epilog.js", jslite)

  puts 'Compiling appcelerator-debug.js...' if VERBOSE
  
  jsdebug = js_dir+'/appcelerator-debug.js'
  append_file(LICENSE_HEADER,jsdebug,true)
  append_file("\n/* The following files are subject to license agreements by their respective license owners */\n", jsdebug, true)
  append_file(js_source+'/prolog.js', jsdebug)
  thirdparty = %w(prototype/prototype.js scriptaculous/scriptaculous.js scriptaculous/effects.js scriptaculous/dragdrop.js scriptaculous/resizable.js)
  thirdparty.each do |file|
    append_file(BUILD_DIR+'/lib/'+file, jsdebug)
  end
  append_file("\n/* END THIRD PARTY SOURCE */\n", jsdebug, true)
  append_file(jslite, jsdebug)
  
  puts 'Compiling appcelerator.js...' if VERBOSE
  jsout = js_dir+'/appcelerator.js'
  jstemp = js_dir+'/appcelerator-temp.js'
  
  # Strip out scriptaculous's load - since we include its files already
  jsd = File.read(jsdebug)
  jsd.gsub!('Scriptaculous.load();','')
  jsdf = File.open(jsdebug,'w+')
  jsdf.write jsd
  jsdf.close
  
  # Make the compressors quiet, but if a fatal error occurs, display output
  require 'tempfile'
  require 'tmpdir'
  ERROR_TEMP_FILE = Tempfile.new('websdk').path
   
  if VERBOSE or is_win32
    SUPPRESS_OUTPUT = ""
  else
    SUPPRESS_OUTPUT = ">#{to_path ERROR_TEMP_FILE} 2>&1"
  end
  
  def compress_fail
    if not VERBOSE
      puts File.read(ERROR_TEMP_FILE)
    end
    fail("Syntax error in websdk source, unable to compress")
  end

  jar = to_path "#{BUILD_DIR}/lib/yuicompressor-2.2.5.jar"
  YUI_COMPRESSOR = "java -jar #{jar}"
  COMPRESS_RB = "ruby #{BUILD_DIR}/lib/compress.rb"
  
  if COMPRESS
    puts "Compressing appcelerator.js"
    call_command("#{YUI_COMPRESSOR} #{jsdebug} -o #{jsout} #{SUPPRESS_OUTPUT}") || compress_fail
    call_command("#{COMPRESS_RB} #{jsout} #{jstemp} #{SUPPRESS_OUTPUT}") || compress_fail
    FileUtils.rm jsout
    append_file(LICENSE_HEADER, jsout, true)
    append_file(jstemp, jsout)
    FileUtils.rm jstemp

    call_command("#{YUI_COMPRESSOR} #{jslite} -o #{jstemp} #{SUPPRESS_OUTPUT}") || compress_fail
    call_command("#{COMPRESS_RB} #{jstemp} #{jslite} #{SUPPRESS_OUTPUT}") || compress_fail
    FileUtils.rm jstemp
    append_file(LICENSE_HEADER, jstemp, true)
    append_file(jslite, jstemp)
    FileUtils.rm jslite
    append_file(jstemp, jslite)
    FileUtils.rm jstemp
  else
    FileUtils.cp jsdebug, jsout
  end

  puts "Archiving JS/Web files..." if VERBOSE
  zipfile = "#{STAGE_DIR}/websdk_#{build_config[:version]}.zip"
  FileUtils.rm_rf zipfile if File.exists? zipfile
  Zip::ZipFile.open(zipfile, Zip::ZipFile::CREATE) do |zipfile|
    zipfile.add("#{JS_PATH}/appcelerator-lite.js",jslite)
    zipfile.add("#{JS_PATH}/appcelerator-debug.js",jsdebug)
    zipfile.add("#{JS_PATH}/appcelerator.js",jsout)
    zipfile.get_output_stream('build.yml') {|f| f.puts build_config.to_yaml }
    Find.find("#{BUILD_DIR}/src/web") do |path|
      pathname = Pathname.new(path)
      path_root = Pathname.new("#{BUILD_DIR}/src/web")
      if not path.include? '.svn' and not path.include? '.DS_Store' and pathname.file?
        filename = pathname.relative_path_from(path_root).to_s
        zipfile.add(filename,path) if not filename =~ /^js(.*)\.js$/
      end
    end
    Find.find("#{BUILD_DIR}/src/common") do |path|
      pathname = Pathname.new(path)
      path_root = Pathname.new("#{BUILD_DIR}/src/common")
      if not path.include? '.svn' and not path.include? '.DS_Store' and pathname.file?
        filename = pathname.relative_path_from(path_root).to_s
        zipfile.add('common/' + filename,path)
      end
    end
  end
end

task :test => [:default] do
  test_src_path = "#{BUILD_DIR}/test/webunit"
  test_dst_path = "#{STAGE_DIR}/webunit"
  widgets_src_path = "#{BUILD_DIR}/../widgets"
  widgets_dst_path = "#{test_dst_path}/widgets"
  
  FileUtils.rm_r(test_dst_path, :verbose => VERBOSE) if File.exists? test_dst_path
  cp_r(test_src_path, test_dst_path)
  FileUtils.cp_r("#{WEBSDK_STAGE_DIR}/#{JS_PATH}", test_dst_path) # there's no svn garbage here
  FileUtils.mkdir_p(widgets_dst_path, :verbose => VERBOSE)
  cp_r("#{BUILD_DIR}/src/common",       "#{test_dst_path}/widgets/common")
  cp_r("#{BUILD_DIR}/src/web/images/", "#{test_dst_path}/images/")
  cp_r("#{BUILD_DIR}/src/web/swf/", "#{test_dst_path}/swf/")

  # copy all widgets (without building, because that is a pain)
  Dir["#{widgets_src_path}/*/src/"].each do |file|
    name = file[/widgets\/([^\/]+)\/src/,1]
    cp_r(file,"#{widgets_dst_path}/#{name}")
  end
  
end

namespace :selenium do 
  task :start do
      start_selenium()
  end
  
  task :stop do 
      stop_selenium()
  end
  
  task :all => [:test] do 
    webrick = start_webrick()
    selenium = start_selenium()
  
    sleep 5 if( selenium or webrick )
    run_selenium_tests("Firefox Tests", "firefox")
    # run_selenium_tests("Safari Tests", "safari")
    run_selenium_tests("IE Tests", "iexplore")
    
    stop_selenium() if selenium
    stop_webrick() if webrick
  end
  
  task :firefox => [:test] do 
    webrick = start_webrick()
    selenium = start_selenium()
  
    sleep 5 if( selenium or webrick )
    run_selenium_tests("Firefox Tests", "firefox")
  
    stop_selenium() if selenium
    stop_webrick() if webrick
  end

  task :safari => [:test] do 
    selenium = start_selenium()
    webrick = start_webrick()
    
    sleep 5 if( selenium or webrick)
    run_selenium_tests("Safari Tests", "safari")
    
    stop_selenium() if selenium
    stop_webrick() if webrick
  end
  
  task :ie => [:test] do 
    selenium = start_selenium()
    webrick = start_webrick()
    
    sleep 5 if( selenium or webrick)
    run_selenium_tests("IE Tests", "iexplore")
    
    stop_selenium() if selenium
    stop_webrick() if webrick
  end
end

namespace :webrick do 
  task :start do
    start_webrick()
  end
  
  task :stop do 
    stop_webrick()
  end
end

# copies everything except hidden directories
def cp_r(src,dst)
  src_root = Pathname.new(src)
  FileUtils.mkdir_p(dst, :verbose => VERBOSE)
  Dir["#{src}/**/**"].each do |abs_path|
    src_path = Pathname.new(abs_path)
    rel_path = src_path.relative_path_from(src_root)
    dst_path = "#{dst}/#{rel_path.to_s}"
    
    if src_path.directory?
      FileUtils.mkdir_p(dst_path, :verbose => VERBOSE)
    elsif src_path.file?
      FileUtils.cp(abs_path, dst_path, :verbose => VERBOSE)
    end
  end
end

def start_webrick()
  if(File.exists?("#{STAGE_DIR}/tmp/webrick.pid"))
    return false
  end
  p "Starting Webrick"
  
  FileUtils.mkdir_p("#{STAGE_DIR}/tmp/", :verbose => true)
  
  if RUBY_PLATFORM.match(/win32/)
    require 'win32/process'
    process_info = Process.create(:app_name => "ruby  #{BUILD_DIR}\\test\\lib\\start_webrick.rb #{STAGE_DIR}")
    File.open("#{STAGE_DIR}/tmp/webrick.pid", "w") { |file| 
      file.puts(process_info.process_id)
    }
  else 
    pid = fork
    if pid 
      File.open("#{STAGE_DIR}/tmp/webrick.pid", "w") { |file| 
        file.puts(pid)
      }
    else 
      exec "ruby  #{BUILD_DIR}/test/lib/start_webrick.rb #{STAGE_DIR}"
    end
  end
  
  return true
end 

def kill_process(file_name)
  signum = 15
  if RUBY_PLATFORM.match(/win32/)
    require 'win32/process'
    signum = 9
  end
  file = File.open(file_name)
  pid = file.gets.strip!.to_i
  file.close
  p "Attempting to kill: #{pid}"
  Process.kill(signum, pid)
  File.delete(file_name)
end

def stop_webrick()
  kill_process("#{STAGE_DIR}/tmp/webrick.pid")
end

def start_selenium()
  if(File.exists?("#{STAGE_DIR}/tmp/selenium.pid"))
    return false
  end
  
  p "Starting Selenium"
  FileUtils.mkdir_p("#{STAGE_DIR}/tmp/", :verbose => true)
  
  if RUBY_PLATFORM.match(/win32/)
    require 'win32/process'
    log = File.open("#{STAGE_DIR}/tmp/selenium.log", "w")
    process_info = Process.create(
        :app_name => "java -jar #{BUILD_DIR}\\test\\lib\\selenium-server.jar -browserSessionReuse",
        :startup_info => {:stdout => log}
    )
    File.open("#{STAGE_DIR}/tmp/selenium.pid", "w") { |file| 
      file.puts(process_info.process_id)
    }
  else 
    pid = fork
    if pid 
      File.open("#{STAGE_DIR}/tmp/selenium.pid", "w") { |file| 
        file.puts(pid)
      }
    else
      $stdout.close
      $stdout = open("#{STAGE_DIR}/tmp/selenium.log", "w") 
      exec "java -jar #{BUILD_DIR}/test/lib/selenium-server.jar -browserSessionReuse"
      p "Shouldn't get here"
    end
  end
  
  return true
end

def stop_selenium()
  kill_process("#{STAGE_DIR}/tmp/selenium.pid")
end

def run_selenium_tests(browser_name, browser)
  require 'test/unit/testsuite'
  require 'test/unit/ui/console/testrunner'
  require 'test/lib/selenium'
  require 'test/lib/selenium_unit.rb'

  #
  # You need to manually include the tests
  # to be run here.  
  #
  require 'test/selenium/app_button_test'
  require 'test/selenium/messaging_test'
  #
  # End includes for unit test files
  #
  
  Test::Unit::UI::Console::TestRunner.run(build_suite(browser_name, browser, 
         "http://localhost:9002/widget_tests"))
end

def build_suite(name, browser, location)
    tests = ENV['tests']
    if tests 
        tests = tests.split(',')
    end
    
    suite = Test::Unit::SeleniumTestSuite.new(name, browser, location)
    ObjectSpace::each_object(Class) { |klass| 
        if klass < Test::Unit::SeleniumTestCase and (tests.nil? or tests.include?(klass.to_s))
            puts "Adding: #{klass}"
            suite << klass.suite 
        end
    }
    return suite
end